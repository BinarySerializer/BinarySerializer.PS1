using System;

namespace BinarySerializer.PS1
{
    public class PS1_TMD_Packet : BinarySerializable
    {
        /// <summary>
        /// Indicates the word length of the 2D drawing primitives that are generated by intermediate processing.
        /// </summary>
        public byte OLen { get; set; }

        /// <summary>
        /// Indicates the length, in words, of the packet data section.
        /// </summary>
        public byte ILen { get; set; }

        public PacketFlags Flags { get; set; }

        public PS1_TMD_PacketMode Mode { get; set; }

        // Data

        public PS1_TMD_Color[] RGB { get; set; }
        public ushort[] Vertices { get; set; }
        public PS1_TMD_UV[] UV { get; set; }

        public PS1_CBA CBA { get; set; }
        public PS1_TSB TSB { get; set; }

        public override void SerializeImpl(SerializerObject s)
        {
            OLen = s.Serialize<byte>(OLen, name: nameof(OLen));
            ILen = s.Serialize<byte>(ILen, name: nameof(ILen));
            Flags = s.Serialize<PacketFlags>(Flags, name: nameof(Flags));
            Mode = s.SerializeObject<PS1_TMD_PacketMode>(Mode, name: nameof(Mode));

            var endPointer = s.CurrentPointer + ILen * 4;

            if (Mode.Code == PS1_TMD_PacketMode.PacketModeCODE.Polygon)
            {
                // Has light source
                if (!Flags.HasFlag(PacketFlags.LGT))
                {
                    throw new NotImplementedException("Serialize polygon with light source");
                }
                else
                {
                    // Check if it has a texture
                    if (Mode.TME)
                    {
                        UV ??= new PS1_TMD_UV[Mode.IsQuad ? 4 : 3];

                        UV[0] = s.SerializeObject<PS1_TMD_UV>(UV[0], name: $"{nameof(UV)}[0]");
                        CBA = s.SerializeObject<PS1_CBA>(CBA, name: nameof(CBA));
                        UV[1] = s.SerializeObject<PS1_TMD_UV>(UV[1], name: $"{nameof(UV)}[1]");
                        TSB = s.SerializeObject<PS1_TSB>(TSB, name: nameof(TSB));
                        UV[2] = s.SerializeObject<PS1_TMD_UV>(UV[2], name: $"{nameof(UV)}[2]");
                        s.Align();

                        if (Mode.IsQuad)
                        {
                            UV[3] = s.SerializeObject<PS1_TMD_UV>(UV[3], name: $"{nameof(UV)}[3]");
                            s.Align();
                        }
                    }

                    var rgbLength = 1;

                    if (Mode.IIP)
                        rgbLength = Mode.IsQuad ? 4 : 3;

                    RGB = s.SerializeObjectArray<PS1_TMD_Color>(RGB, rgbLength, name: nameof(RGB));

                    Vertices = s.SerializeArray<ushort>(Vertices, Mode.IsQuad ? 4 : 3, name: nameof(Vertices));

                    s.Align();
                }
            }
            else if (Mode.Code == PS1_TMD_PacketMode.PacketModeCODE.StraightLine)
            {
                throw new NotImplementedException("Serialize straight line");
            }
            else if (Mode.Code == PS1_TMD_PacketMode.PacketModeCODE.Sprite)
            {
                throw new NotImplementedException("Serialize 3D sprite");
            }
            else
            {
                throw new BinarySerializableException(this, $"Invalid packet mode code {Mode.Code}");
            }

            if (s.CurrentPointer != endPointer)
            {
                s.LogWarning($"Packet was not fully serialized. Expected end was {endPointer}, end is {s.CurrentPointer}.");
                s.Goto(endPointer);
            }
        }

        [Flags]
        public enum PacketFlags : byte
        {
            None = 0,

            /// <summary>
            /// 1: Light source calculation not carried out
            /// 0: Light source calculation carried out
            /// </summary>
            LGT = 1 << 0,

            /// <summary>
            /// 1: Double-faced polygon
            /// 0: Single-faced polygon
            /// (Valid, only when the CODE value refers to a polygon.)
            /// </summary>
            FCE = 1 << 1,

            /// <summary>
            /// Valid only for the polygon not textured, subjected to light source calculation.
            /// 1: Gradation polygon
            /// 0: Single-color polygon
            /// </summary>
            GRD = 1 << 2,
        }
    }
}